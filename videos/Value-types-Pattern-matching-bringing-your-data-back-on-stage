https://www.youtube.com/watch?v=tWonozjIE-s
Part one : introduction + demo

- OOP is used in Java
    - Adding methods in interface breaks I in SOLID: 
    - Using encapsulation to define a public API, hiding internals. 
    - Traditional ‘OOP approach’: Interfaces are used together with polymorphism. Behavior is tied to the class
- Turning it around with DOP.
    - DOP is also interesting because the compiler can help out a lot more than using the traditional approach 
    - Data is just data and behavior is not tied to the data. 
    - For this, use following (java 21) features
        - Marker interfaces to tell the data which type it is (for instance, City,Department, Country implement the Populated interface)
            - The interface is sealed, but permits the data. This allows for exhaustive switch expression matching
        - The data itself is modelled as RECORDS
            - Records are final, but can implementtjhe marker interface
        - Switch expression
            - Case null -> to handle null
            -  way to check *exhaustively* every single type of data
            - Yield statement can be used to escape from within the switch expression but stay in the method. One cannot use the return keyword because it is ambiguous with the other return 
            - More fine-grained control of when to execute what branch for a certain type when using the ‘when’ keyword!
        - Pattern matching for switch. 
            - easily recognize which type of data object we are dealing with (instead of having to use instanceof ).
            - Deconstructing a record is possible (‘Record Patterns’ - JEP 440 )
                - Why on earth would we use it instead of passing the entire record and accessing the components?
                    - Because Changing the components of your record will then give a compiler error. This is what we want! (Although Im not happy about having to copy paste components on my switch…)
                    - Verbosity can be reduced by using ‘unnamed patterns’:  we can specify it with an _ (a so called unnamed pattern variable)
                        - It can also be used to combine ‘default’ branches. Lets says for 2 types we just want to return default value. Declare them in same branch like so case Type1 _,Type2 _; -> “default”
        - The behavior is modelled separately (as a static method)

Part two : timeline for further dev

- Don’t always use DOP. Data is not always more important than code
- Wadler’s expression of the problem:
    - Polymorphism allows for adding new subtypes, but sucks for defining new operations
    - Pattern matching doesn’t allow for adding new subtypes, but is great for extending with new operations
    - One can’t have both (research languages have tried)
- Matchers etc are inc but not part of J21

Part 3 : design patterns
- Primitive types vs using objects
    - Using types (via objects) is more readable than choosing readable variable name
        - Performance hit, sure (pointer chasing) but readability trumps performance and the loss is negligible. 
        - Example of the histogram
            - Map<String,integer> popByCity = …;
            - Map<City,Population> popByCity = …; (where City and Population are records instead of string and integer)
    - Valhalla wants to make this a cost free abstraction 
        - Value class is part of the solution: These classes gives up it identity, it has no address in memory

